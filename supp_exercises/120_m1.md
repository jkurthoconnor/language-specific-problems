120 Object Oriented Programming [Medium 1](https://launchschool.com/exercise_sets/e0cc58f8)

### 1. Privacy

Consider the following class:
```ruby
class Machine
  attr_writer :switch

  def start
    self.flip_switch(:on)
  end

  def stop
    self.flip_switch(:off)
  end

  def flip_switch(desired_state)
    self.switch = desired_state
  end
end
```

Modify this class so both flip_switch and the setter method switch= are private methods.

#### Solution:

```ruby
class Machine

  def start
    flip_switch(:on)
  end

  def stop
    flip_switch(:off)
  end

  private

  attr_writer :switch

  def flip_switch(desired_state)
    self.switch = desired_state
  end
end
```

#### Further Exploration

Add a private getter for `@switch` to the Machine class, and add a method to Machine that shows how to use that getter.

#### Solution:

```ruby
class Machine

  def start
    flip_switch(:on)
  end

  def stop
    flip_switch(:off)
  end

  def return_status
    switch
  end

  private

  attr_accessor :switch

  def flip_switch(desired_state)
    self.switch = desired_state
  end
end

mac = Machine.new
mac.start
p mac.return_status
mac.stop
p mac.return_status
```

### 2. Fixed Array

A fixed-length array is an array that always has a fixed number of elements. Write a class that implements a fixed-length array, and provides the necessary methods to support the following code:

```ruby
fixed_array = FixedArray.new(5)
puts fixed_array[3] == nil
puts fixed_array.to_a == [nil] * 5

fixed_array[3] = 'a'
puts fixed_array[3] == 'a'
puts fixed_array.to_a == [nil, nil, nil, 'a', nil]

fixed_array[1] = 'b'
puts fixed_array[1] == 'b'
puts fixed_array.to_a == [nil, 'b', nil, 'a', nil]

fixed_array[1] = 'c'
puts fixed_array[1] == 'c'
puts fixed_array.to_a == [nil, 'c', nil, 'a', nil]

fixed_array[4] = 'd'
puts fixed_array[4] == 'd'
puts fixed_array.to_a == [nil, 'c', nil, 'a', 'd']
puts fixed_array.to_s == '[nil, "c", nil, "a", "d"]'

puts fixed_array[-1] == 'd'
puts fixed_array[-4] == 'c'

begin
  fixed_array[6]
  puts false
rescue IndexError
  puts true
end

begin
  fixed_array[-7] = 3
  puts false
rescue IndexError
  puts true
end
```

The above code should output true 15 times.

### Solution:

```ruby
class FixedArray

  def initialize(size)
    @array = Array.new(size)
  end

  def to_a
    @array.clone
  end
  
  def to_s
    to_a.to_s
  end
  
  def [](index)
    raise IndexError if index > @array.size - 1
    @array[index]
  end
  
  def []=(index, value)
    raise IndexError if index > @array.size - 1
    @array[index] = value
  end
end
```

### 3. Students

Below we have 3 classes: Student, Graduate, and Undergraduate. Some details for these classes are missing. Make changes to the classes below so that the following requirements are fulfilled:

Graduate students have the option to use on-campus parking, while Undergraduate students do not.

Graduate and Undergraduate students have a name and year associated with them.

Note, you can do this by adding or altering no more than 5 lines of code.

```ruby
class Student
  def initialize(name, year)
    @name = name
    @year = year
  end
end

class Graduate
  def initialize(name, year, parking)
  end
end

class Undergraduate
  def initialize(name, year)
  end
end
```

#### Solution:

```ruby
class Student
  def initialize(name, year)
    @name = name
    @year = year
  end
end

class Graduate < Student
  def initialize(name, year, parking)
    super(name, year)
    @parking_location = parking
  end
end

class Undergraduate < Student
  def initialize(name, year)
    super
  end
end
```

### 4. Circular Queue

A circular queue is a collection of objects stored in a buffer that is treated as though it is connected end-to-end in a circle. When an object is added to this circular queue, it is added to the position that immediately follows the most recently added object, while removing an object always removes the object that has been in the queue the longest.

This works as long as there are empty spots in the buffer. If the buffer becomes full, adding a new object to the queue requires getting rid of an existing object; with a circular queue, the object that has been in the queue the longest is discarded and replaced by the new object.

Assuming we have a circular queue with room for 3 objects, the circular queue looks and acts like this:
P1	P2	P3	Comments
            All positions are initially empty
1			      Add 1 to the queue
1	2		      Add 2 to the queue
2		        Remove oldest item from the queue (1)
2	3	        Add 3 to the queue
4	2	3	      Add 4 to the queue, queue is now full
4		3	      Remove oldest item from the queue (2)
4	5	3	      Add 5 to the queue, queue is full again
4	5	6	      Add 6 to the queue, replaces oldest element (3)
7	5	6	      Add 7 to the queue, replaces oldest element (4)
7		6	      Remove oldest item from the queue (5)
7			      Remove oldest item from the queue (6)
            Remove oldest item from the queue (7)
            Remove non-existent item from the queue (nil)
            
Your task is to write a CircularQueue class that implements a circular queue for arbitrary objects. The class should obtain the buffer size with an argument provided to CircularQueue::new, and should provide the following methods:

`enqueue` to add an object to the queue
`dequeue` to remove (and return) the oldest object in the queue. It should return nil if the queue is empty.
You may assume that none of the values stored in the queue are nil (however, nil may be used to designate empty spots in the buffer).

Examples:

```ruby
queue = CircularQueue.new(3)
puts queue.dequeue == nil

queue.enqueue(1)
queue.enqueue(2)
puts queue.dequeue == 1

queue.enqueue(3)
queue.enqueue(4)
puts queue.dequeue == 2

queue.enqueue(5)
queue.enqueue(6)
queue.enqueue(7)
puts queue.dequeue == 5
puts queue.dequeue == 6
puts queue.dequeue == 7
puts queue.dequeue == nil

queue = CircularQueue.new(4)
puts queue.dequeue == nil

queue.enqueue(1)
queue.enqueue(2)
puts queue.dequeue == 1

queue.enqueue(3)
queue.enqueue(4)
puts queue.dequeue == 2

queue.enqueue(5)
queue.enqueue(6)
queue.enqueue(7)
puts queue.dequeue == 4
puts queue.dequeue == 5
puts queue.dequeue == 6
puts queue.dequeue == 7
puts queue.dequeue == nil
```
The above code should display true 15 times.

#### Solution:

```ruby
class CircularQueue
  def initialize(size)
    @queue_limit = size
    @queue = Array.new(@queue_limit)
    @ordered_list = []
  end

  def dequeue
    indx = @queue.index(@ordered_list.shift)
    @queue.insert(indx, nil)
    @queue.delete_at(indx + 1)
  end

  def enqueue(object)
    nils =  @queue.count(nil)
    dequeue if nils.zero?
    @ordered_list.push(object)
    insertion_point = @queue.index(nil)
    @queue.delete_at(insertion_point)
    @queue.insert(insertion_point, object)
  end
end
```

#### Further Exploration

Phew. That's a lot of work, but it's a perfectly acceptable solution to this exercise. However, there is a simpler solution that uses an Array, and the #push and #shift methods. See if you can up with a solution that does this.

#### Solution:

My solution already appears to meet the requirements of the Further Exploration.