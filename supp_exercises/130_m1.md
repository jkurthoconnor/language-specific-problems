130: Ruby Foundations: More Topics
[Medium 1](https://launchschool.com/exercise_sets/f3f8b728)

### 1. Listening Device

Below we have a listening device. It lets us record something that is said and store it for later use. In general, this is how the device should be used:

Listen for something, and if anything is said, record it for later use. If nothing is said, then do not record anything.

```ruby
class Device
  def initialize
    @recordings = []
  end

  def record(recording)
    @recordings << recording
  end
end
```

Anything that is said is retrieved by this listening device via a block. If nothing is said, then no block will be passed in. The listening device can also output what was recently recorded using a Device#play method.

```ruby
listener = Device.new
listener.listen { "Hello World!" }
listener.listen
listener.play # Outputs "Hello World!"
```

Finish the above program so that the specifications listed above are met.

#### Solution:

```ruby
class Device
  def initialize
    @recordings = []
  end

  def record(recording)
    @recordings << recording
  end

  def listen
    record(yield) if block_given?
  end

  def play
    p "#{@recordings.last}"
  end
end
```

### 2. Text Analyzer - Sandwich Code

Fill out the rest of the Ruby code below so that output similar to "Sample Output" is sent to the terminal. To get such output, read some text from a file in process and pass that text to the block provided to each call. Note, that the everything you need to work on is either part of the process method or part of one of the 3 blocks. No other additions or changes are required. The text you use does not have to produce the same numbers as the sample output, but should have the indicated format.

```ruby
class TextAnalyzer
  def process
    # your implementation
  end
end

analyzer = TextAnalyzer.new
analyzer.process { |file| puts # your implementation }
analyzer.process { |file| puts # your  implementation }
analyzer.process { |file| puts # your implementation }

# Sample Output:

3 paragraphs
25 lines
306 words
```

#### Solution:

```ruby
class TextAnalyzer
  def process
    File.open('sample.txt', 'r') do |file|
      yield(file.read)
      file.close
    end
  end
end

analyzer = TextAnalyzer.new
analyzer.process { |text| puts "#{text.split("\n\n").count}  paragraph(s)" }
analyzer.process { |text| puts "#{text.split(".\n").count} line(s)" }
analyzer.process { |text| puts "#{text.split.count} word(s)" }
```

### 3. Passing Parameters, Part 1

Modify the method below so that the display/output of items is moved to a block, and its implementation is left up to the user of the gather method.

```ruby
items = ['apples', 'corn', 'cabbage', 'wheat']

def gather(items)
  puts "Let's start gathering food."
  puts "#{items.join(', ')}"
  puts "Let's start gathering food."
end
```

#### Solution:

```ruby
items = ['apples', 'corn', 'cabbage', 'wheat']

def gather(items)
  puts "Let's start gathering food."
  yield(items)
  puts "Let's start gathering food."
end

gather(items) { puts "#{items.join(', ')}" }
```

### 4. Passing Parameters, Part 2

But, what if we wanted to organize our array contents into categories, where variables represent category names. Could we do that without directly grabbing certain items from particular array indices?

There is one way to do it, and that is by using the splat operator `*`. We can do something like this

```ruby
raven, finch, *birds_of_prey = %w(raven finch hawk eagle)
p raven # => 'raven'
p finch # => 'finch'
p birds_of_prey # => ['hawk','eagle']
```

Based on the information given above, write a method that takes an array as an argument. In that method, yield the contents of the array to a block. In the block, write your block variables in such a way that the first two items are discarded, and the last time items are treated as birds of prey.

#### Solution:

```ruby
def do_something_with_names(array)
  yield(array)
end

flying_things = [ 'airplanes', 'flies', 'hawks', 'eagles', 'falcons' ]

do_something_with_names(flying_things) { |item1, item2, *raptors | puts "#{raptors}" }
```


### 5. Passing Parameters, Part 3

Given this code:

```ruby
items = ['apples', 'corn', 'cabbage', 'wheat']

def gather(items)
  puts "Let's start gathering food."
  yield(items)
  puts "We've finished gathering!"
end
```

Fill out the following method calls for gather so that they produce the corresponding output shown in numbers 1-4 listed below:

```ruby
# 1

gather(items) do | , |
  puts
  puts
end

Let's start gathering food.
apples, corn, cabbage
wheat
We've finished gathering!

# 2

gather(items) do | , , |
  puts
  puts
  puts
end
Let's start gathering food.
apples
corn, cabbage
wheat
We've finished gathering!

```

#### Solutions:

```ruby
items = ['apples', 'corn', 'cabbage', 'wheat']

def gather(items)
  puts "Let's start gathering food."
  yield(items)
  puts "We've finished gathering!"
end

# 1
gather(items) do | *gluten_free, glutenous|
  puts gluten_free.join(', ')
  puts glutenous
end

# 2
gather(items) do | fruit, *veggies, gluten |
  puts fruit
  puts veggies.join(', ')
  puts gluten
end

# 3
gather(items) do | fruit, *other_stuff |
  puts fruit
  puts other_stuff.join(', ')
end

# 4
gather(items) do | item1, item2, item3, item4 |
  puts "#{item1}, #{item2}, #{item3}, and #{item4}"
end
```

### 6. Exploring Procs, Lambdas, and Blocks: Definitions and Arity


### 7. Exploring Procs, Lambdas, and Blocks: Returning


### 8. Method to Proc


### 9. Internal vs External Iterators


### 10. Bubble Sort with Blocks
