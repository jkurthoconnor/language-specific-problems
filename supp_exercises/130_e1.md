130: Ruby Foundations: More Topics
[Easy 1](https://launchschool.com/exercise_sets/f55e7ba0)

### 1. Enumerable Class Creation

Assume we have a `Tree` class that implements a binary tree.

```ruby
class Tree
  ...
end
```

A binary tree is just one of many forms of collections, such as Arrays, Hashes, Stacks, Sets, and more. All of these collection classes include the `Enumerable` module, which means they have access to an `each` method, as well as many other iterative methods such as `map`, `reduce`, `select`, and more.

For this exercise, modify the `Tree` class to support the methods of `Enumerable`. You do not have to actually implement any methods -- just show the methods that you must provide.

#### Solution:
```ruby
class Tree
  include Enumerable
  
  def each
    # implementation ...
  end
  
  # additional code ...
end
```

### 2. Optional Blocks

Write a method that takes an optional block. If the block is specified, the method should execute it, and return the value returned by the block. If no block is specified, the method should simply return the String 'Does not compute.'.

Examples:
```ruby
compute { 5 + 3 } == 8
compute { 'a' + 'b' } == 'ab'
compute == 'Does not compute.'
```

#### Solution:

```ruby 
def compute
  block_given? ? yield : 'Does not compute.'
end
```

#### Further Exploration:

Modify the `compute` method so it takes a single argument and yields that argument to the block. Provide at least 3 examples of calling this new version of `compute`, including a no-block call.

#### Solution:

```ruby
def compute(input)
  block_given? ? yield(input) : "All I have to work with is #{input}."
end

puts compute(5) { |n| n * 5 }
puts compute(10) { |n| n * 4 }
puts compute('hi ') { |str| str * 10 }
puts compute(11)
```

### 3. Find Missing Numbers

Write a method that takes a sorted array of integers as an argument, and returns an array that includes all of the missing integers (in order) between the first and last elements of the argument.

Examples:
```ruby
missing([-3, -2, 1, 5]) == [-1, 0, 2, 3, 4]
missing([1, 2, 3, 4]) == []
missing([1, 5]) == [2, 3, 4]
missing([6]) == []
```

#### Solution:

```ruby
def missing(sorted_array)
  range = (sorted_array.first..sorted_array.last).to_a
  index = 0
  while index < range.length
    if sorted_array.include?(range[index])
      range.delete_at(index) 
      next
    end
    index += 1
  end
  range
end

missing([-3, -2, 1, 5]) == [-1, 0, 2, 3, 4]
missing([1, 2, 3, 4]) == []
missing([1, 5]) == [2, 3, 4]
missing([6]) == []
```

#### Further Exploration

Can you find other ways to solve this problem? What methods might prove useful? Can you find a way to solve this without using a method that requires a block?

#### Solution

My original solution addresses the desiderata of Further Explorations.

### 4. Divisors

Write a method that returns a list of all of the divisors of the positive integer passed in as an argument. The return value can be in any sequence you wish.

Examples
```ruby
divisors(1) == [1]
divisors(7) == [1, 7]
divisors(12) == [1, 2, 3, 4, 6, 12]
divisors(98) == [1, 2, 7, 14, 49, 98]
divisors(99400891) == [1, 9967, 9973, 99400891] # may take a minute
```

#### Solution:

```ruby
# def divisors(integer)
#   divs = []
#   (1..integer).each do |n|
#     divs << n if (integer % n).zero?
#   end
#   divs
# end
# 
# # or

def divisors(integer)
  (1..integer).select { |n| (integer % n).zero? }
end

divisors(1) == [1]
divisors(7) == [1, 7]
divisors(12) == [1, 2, 3, 4, 6, 12]
divisors(98) == [1, 2, 7, 14, 49, 98]
divisors(99400891) == [1, 9967, 9973, 99400891] # may take a minute
```

#### Further Exploration
How fast can you make your solution go? How big of a number can you quickly reduce to its divisors? Can you make divisors(999962000357) return almost instantly? (The divisors are [1, 999979, 999983, 999962000357].) Hint: half of the divisors gives you the other half.

Solution:
```ruby 

```

#### 5. Encrypted Pioneers

The following list contains the names of individuals who are pioneers in the field of computing or that have had a significant influence on the field. However, the names are in an encrypted form, using a very simple (and incredibly weak) form of encryption called rot 13.

Write a program that deciphers and prints each of these names:

Nqn Ybirynpr
Tenpr Ubccre
Nqryr Tbyqfgvar
Nyna Ghevat
Puneyrf Onoontr
Noqhyynu Zhunzznq ova Zhfn ny-Xujnevmzv
Wbua Ngnanfbss
Ybvf Unyog
Pynhqr Funaaba
Fgrir Wbof
Ovyy Tngrf
Gvz Orearef-Yrr
Fgrir Jbmavnx
Xbaenq Mhfr
Wbua Ngnanfbss
Fve Nagbal Ubner
Zneiva Zvafxl
Lhxvuveb Zngfhzbgb
Unllvz Fybavzfxv
Tregehqr Oynapu

#### Solution:

```ruby
encoded_names = [
                "Nqn Ybirynpr", "Tenpr Ubccre", "Nqryr Tbyqfgvar",
                "Nyna Ghevat", "Puneyrf Onoontr", 
                "Noqhyynu Zhunzznq ova Zhfn ny-Xujnevmzv", "Wbua Ngnanfbss",
                "Ybvf Unyog", "Pynhqr Funaaba", "Fgrir Wbof", "Ovyy Tngrf",
                "Gvz Orearef-Yrr", "Fgrir Jbmavnx", "Xbaenq Mhfr",
                "Wbua Ngnanfbss", "Fve Nagbal Ubner", "Zneiva Zvafxl", 
                "Lhxvuveb Zngfhzbgb", "Unllvz Fybavzfxv", "Tregehqr Oynapu"
              ]

rot13_cipher = {
               "a"=>"n", "b"=>"o", "c"=>"p", "d"=>"q", "e"=>"r",
               "f"=>"s", "g"=>"t", "h"=>"u", "i"=>"v", "j"=>"w",
               "k"=>"x", "l"=>"y", "m"=>"z", "n"=>"a", "o"=>"b",
               "p"=>"c", "q"=>"d", "r"=>"e", "s"=>"f", "t"=>"g",
               "u"=>"h", "v"=>"i", "w"=>"j", "x"=>"k", "y"=>"l",
               "z"=>"m"
              }

def decode(string, cipher)

  decoded_chars = []

  string.each_char do |char|
    decoded_chars.push(char) unless cipher.keys.include?(char.downcase)
    if char == char.downcase
      decoded_chars.push(cipher[char])
    else
      decoded_chars.push(cipher[char.downcase].upcase)
    end
  end

  decoded_chars.join
end

encoded_names.map do |name|
  puts decode(name, rot13_cipher)
end
```

#### Further Exploration

[The sample solution used string#ord and shifted 13 spots in one direction or the other, depending on the placement of the encoded letter. This assumes the ASCII encoding.]

Not all computers use ASCII, however. Many mainframes use different schemes such as EBCDIC, which is found on some IBM computers. EBCDIC is unusual: the alphabetic characters are not all grouped together like in ASCII (see the linked page). How would this impact our implementation of this program if we were running this program on data that uses the EBCDIC representation?

#### Solution:

If the character encoding didn't group all letters in a series, then one solution would be to use a look-up hash, as I did above.  It is also possible that there may be a pattern in the way the letters are stored.  If that is the case then perhaps a modified version of the 'shift 13 spots' may work.